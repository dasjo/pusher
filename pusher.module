<?php

/**
 * Implements hook_menu().
 */
function pusher_menu() {
  $items = array();
  $items['realtime.xml'] = array(
    'title' => 'Realtime RSS feed',
    'page callback' => 'pusher_feed_page',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_node_insert().
 */
function pusher_node_insert($node) {
  if (TRUE || TRUE) {
    if ($node->status && $node->promote) {
      pusher_notify($node->nid);
    }
  }
}

/**
 * Implements hook_node_update().
 */
function pusher_node_update($node) {
  if (TRUE || TRUE) {
    if ($node->status && $node->promote) {
      pusher_notify($node->nid);
    }
  }
}

/**
 * Implements hook_nodeapi().
 */
function pusher_nodeapi_OLD($node, $op) { }

/**
 * Send a notification to all subscribers.
 */
function pusher_notify($nid) {
  node_load(NULL, NULL, TRUE);
  $changed = pusher_feed(array($nid));
  push_hub_notify(url('realtime.xml', array('absolute' => TRUE)), $changed, TRUE);
}

/**
 * Page callback for rendering a feed.
 */
function pusher_feed_page() {
  drupal_add_http_header('Content-Type', 'application/rss+xml; charset=utf-8');
  print pusher_feed();
}

/**
 * Recognize node_feed()?
 *
 * Change: feed_url and hub_url embedding, don't print to screen.
 */
function pusher_feed($nids = FALSE, $channel = array()) {
  global $base_url, $language;

/*
  if ($nids === FALSE) {
    $nids = array();
    // TODO Please convert this statement to the D7 database API syntax.
    $result = db_query_range(db_rewrite_sql('SELECT n.nid, n.created FROM {node} n WHERE n.promote = 1 AND n.status = 1 ORDER BY n.created DESC'));
    while ($row = db_fetch_object($result)) {
      $nids[] = $row->nid;
    }
  }
*/
  // TODO filter by $nids
  $nodes_limit = 10;
  $nodes = node_get_recent($nodes_limit);

  // TODO feed_item_length meaning = title with/without teaser?
  $item_length = variable_get('feed_item_length', 'teaser');
  $namespaces = array(
    'xmlns:dc' => 'http://purl.org/dc/elements/1.1/',
    'xmlns:atom' => 'http://www.w3.org/2005/Atom',
  );

  $items = '';
	dsm($nodes);
	dsm($item_length);
	
  foreach ($nodes as $item) {
    // Load the specified node:
    //$item = node_load($nid);
    // TODO constant: $item->build_mode = NODE_BUILD_RSS;
		
    $item->link = url("node/$item->nid", array('absolute' => TRUE));
  
    if ($item_length != 'title') {
      $teaser = ($item_length == 'teaser') ? TRUE : FALSE;

      // Filter and prepare node teaser
      if (node_hook($item, 'view')) {
        $item = node_invoke($item, 'view', $teaser, FALSE);
      }
      else {
        $item = node_prepare($item, $teaser);
      }

      // Allow modules to change $node->content before the node is rendered.
      module_invoke_all('node_view', $item, 'teaser');

      // Set the proper node property, then unset unused $node property so that a
      // bad theme can not open a security hole.
      $content = drupal_render($item->content);
      if ($teaser) {
        $item->teaser = $content;
        unset($item->body);
      }
      else {
        $item->body = $content;
        unset($item->teaser);
      }

      // Allow modules to modify the fully-built node.
      module_invoke_all('node_build_alter', $item, $teaser);
    }

    // Allow modules to add additional item fields and/or modify $item
    $extra = module_invoke_all('node_view', $item, 'rss');
    $extra = array_merge($extra, array(array('key' => 'pubDate', 'value' => gmdate('r', $item->created)), array(
        'key' => 'dc:creator',
        'value' => $item->name,
      ), array(
        'key' => 'guid',
        'value' => $item->nid . ' at ' . $base_url,
        'attributes' => array('isPermaLink' => 'false'),
      )));
    foreach ($extra as $element) {
      if (isset($element['namespace'])) {
        $namespaces = array_merge($namespaces, $element['namespace']);
      }
    }
    

    // Prepare the item description
    switch ($item_length) {
      case 'fulltext':
        $item_text = $item->body;
        break;
      case 'teaser':
        $item_text = $item->teaser;
        if (!empty($item->readmore)) {
          $item_text .= '<p>' . l(t('read more'), 'node/' . $item->nid, array('absolute' => TRUE, 'attributes' => array('target' => '_blank'))) . '</p>';
        }
        break;
      case 'title':
        $item_text = '';
        break;
    }

    $items .= format_rss_item($item->title, $item->link, $item_text, $extra);
  }

  $channel_defaults = array(
    'version' => '2.0',
    'title' => variable_get('site_name', 'Drupal'),
    'link' => $base_url,
    'description' => variable_get('site_mission', ''),
    'language' => $language->language,
  );
  $channel = array_merge($channel_defaults, $channel);

  $feed_url = url('realtime.xml', array('absolute' => TRUE));
  $hub_url = url('pubsubhubbub/endpoint', array('absolute' => TRUE));
  $output = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
  $output .= "<rss version=\"" . $channel["version"] . "\" xml:base=\"" . $base_url . "\" " . drupal_attributes($namespaces) . ">\n";
  $output .= "<atom:link rel=\"hub\" href=\"$hub_url\" />\n";
  $output .= "<atom:link rel=\"self\" href=\"$feed_url\" />\n";
  $output .= format_rss_channel($channel['title'], $channel['link'], $channel['description'], $items, $channel['language']);
  $output .= "</rss>\n";

  return $output;
}
